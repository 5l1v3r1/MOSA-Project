<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@include file="..\..\Templates\DynamicJsonConverter.ttinclude" #>
<#@include file="..\..\Templates\MultipleOutputHelper.ttinclude" #>
<#@ assembly name="Microsoft.CSharp" #>

<# var manager = Manager.Create(Host, GenerationEnvironment); #> 
<# manager.StartHeader(); #>
// Copyright (c) MOSA Project. Licensed under the New BSD License.

// This code was generated by an automated template.

<# manager.EndBlock(); #>
<#
var path = System.IO.Path.GetFullPath(Host.TemplateFile+"\\..\\");
var json = File.ReadAllText(path+"\\..\\"+"X86Instructions.json");

var jss = new JavaScriptSerializer();
jss.RegisterConverters(new JavaScriptConverter[] { new DynamicJsonConverter() });

dynamic entries = jss.Deserialize(json, typeof(object)) as dynamic;

foreach (var entry in entries.Instructions) {

if (entry.X86EmitBytes == null && entry.X86LegacyOpcode == null && entry.StaticEmitMethod == null)
	continue;
#>

<# manager.StartNewFile(entry.Name+".cs"); #>
using Mosa.Compiler.Framework;
<# if (entry.ResultType != null || entry.ResultType2 != null) { #>
using Mosa.Compiler.MosaTypeSystem;
<# } #>

namespace Mosa.Platform.x86.Instructions
{
	/// <summary>
	/// <#= entry.Name #>
<# if (!string.IsNullOrWhiteSpace(entry.Description)) { #>
	/// <#= entry.Description #>
<# } #>
	/// </summary>
	/// <seealso cref="Mosa.Platform.x86.X86Instruction" />
	public sealed class <#= entry.Name #> : X86Instruction
	{
<#
		bool first = true;

		string bytes = string.Empty;
		if (entry.X86EmitBytes != null) {
			foreach (string b in entry.X86EmitBytes.Split(' '))
			{
				string b2 = b.Replace("0x",string.Empty).Replace(",",string.Empty);

				if (!first)
					bytes = bytes + ", ";

				bytes = bytes + "0x" + b2;

				first = false;
			}
		}
		string legacy = string.Empty;
		if (entry.X86LegacyOpcode != null) {
			first = true;
			foreach (string b in entry.X86LegacyOpcode.Split(' '))
			{
				string b2 = b.Replace("0x",string.Empty).Replace(",",string.Empty);

				if (!first)
					legacy = legacy + ", ";

				legacy = legacy + "0x" + b2;

				first = false;
			}
		}

		string reg = string.Empty;
		if (entry.X86LegacyOpcodeRegField != null)
			reg = ", 0x" + entry.X86LegacyOpcodeRegField.Replace("0x",string.Empty);
#>
<# if (entry.X86EmitBytes != null) { #>
		public static readonly byte[] opcode = new byte[] { <#= bytes #> };

<# } #>
<# if (entry.X86LegacyOpcode != null) { #>
		public static readonly LegacyOpCode LegacyOpcode = new LegacyOpCode(new byte[] { <#= legacy #> } <#= reg #>);

<# } #>
		public <#= entry.Name #>()
			: base(<#= entry.ResultCount #>, <#= entry.OperandCount #>)
		{
		}
<# if (entry.FlowControl != null && entry.FlowControl != "Next") { #>

		public override FlowControl FlowControl { get { return FlowControl.<#= entry.FlowControl #>; } }
<# } #>
<# if (entry.ResultType != null && entry.ResultType != "") { #>

		public override BuiltInType ResultType { get { return BuiltInType.<#= entry.ResultType #>; } }
<# } #>
<# if (entry.ResultType2 != null && entry.ResultType2 != "") { #>

		public override BuiltInType ResultType2 { get { return BuiltInType.<#= entry.ResultType2 #>; } }
<# } #>
<# if (entry.IgnoreDuringCodeGeneration  != null && entry.IgnoreDuringCodeGeneration == "true") { #>

		public override bool IgnoreDuringCodeGeneration { get { return true; } }
<# } #>
<# if (entry.IgnoreInstructionBasicBlockTargets  != null && entry.IgnoreInstructionBasicBlockTargets == "true") { #>

		public override bool IgnoreInstructionBasicBlockTargets { get { return true; } }
<# } #>
<# if (entry.VariableOperands != null && entry.VariableOperands == "true") { #>

		public override bool VariableOperands { get { return true; } }
<# } #>
<# if (entry.Commutative  != null && entry.Commutative == "true") { #>

		public override bool IsCommutative { get { return true; } }
<# } #>
<# if (entry.MemoryWrite != null && entry.MemoryWrite == "true") { #>

		public override bool IsMemoryWrite { get { return true; } }
<# } #>
<# if (entry.MemoryRead != null && entry.MemoryRead == "true") { #>

		public override bool IsMemoryRead { get { return true; } }
<# } #>
<# if (entry.IOOperation != null && entry.IOOperation == "true") { #>

		public override bool IsIOOperation { get { return true; } }
<# } #>
<# if (entry.UnspecifiedSideEffect != null && entry.UnspecifiedSideEffect == "true") { #>

		public override bool HasIRUnspecifiedSideEffect { get { return true; } }
<# } #>
<# if (entry.X86ThreeTwoAddressConversion != null && entry.X86ThreeTwoAddressConversion != "true") { #>

		public override bool ThreeTwoAddressConversion { get { return false; } }
<# } #>
<# if (entry.X86EmitBytes != null){ #>

		public override void Emit(InstructionNode node, BaseCodeEmitter emitter)
		{
			System.Diagnostics.Debug.Assert(node.ResultCount == DefaultResultCount || VariableOperands);
			System.Diagnostics.Debug.Assert(node.OperandCount == DefaultOperandCount || VariableOperands);

			emitter.Write(opcode);
		}
<# } #>
<# if (entry.StaticEmitMethod == null && entry.X86LegacyOpcode != null){ #>

		internal override void EmitLegacy(InstructionNode node, X86CodeEmitter emitter)
		{
			System.Diagnostics.Debug.Assert(node.ResultCount == DefaultResultCount || VariableOperands);
			System.Diagnostics.Debug.Assert(node.OperandCount == DefaultOperandCount || VariableOperands);

			System.Diagnostics.Debug.Assert(node.Result == node.Operand1);
			emitter.Emit(LegacyOpcode, node.Result, node.Operand2);
		}
<# } #>
<# if (entry.StaticEmitMethod != null){ #>

		public override void Emit(InstructionNode node, BaseCodeEmitter emitter)
		{
			System.Diagnostics.Debug.Assert(node.ResultCount == DefaultResultCount || VariableOperands);
			System.Diagnostics.Debug.Assert(node.OperandCount == DefaultOperandCount || VariableOperands);

			<#= entry.StaticEmitMethod.Replace("%", entry.Name) #>(node, emitter);
		}
<# } #>
<# if (entry.X86EmitBytes != null || entry.X86LegacyOpcode != null || entry.StaticEmitMethod != null) { #>

		// The following is used by the automated code generator.
<# } #>
<# if (entry.X86EmitBytes != null) { #>

		public override byte[] __opcode { get { return opcode; } }
<# } #>
<# if (entry.X86LegacyOpcode != null) { #>

		public override LegacyOpCode __legacyopcode { get { return LegacyOpcode; } }
<# } #>
<# if (entry.StaticEmitMethod != null) { #>

		public override string __staticEmitMethod { get { return "<#= entry.StaticEmitMethod #>"; } }
<# } #>
	}
}
<# } #>
<# manager.EndBlock(); #>
<# manager.Process(true); #>
