<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@include file="..\..\Templates\DynamicJsonConverter.ttinclude" #>
<#@include file="..\..\Templates\MultipleOutputHelper.ttinclude" #>
<#@ assembly name="Microsoft.CSharp" #>

<# var manager = Manager.Create(Host, GenerationEnvironment); #> 
<# manager.StartHeader(); #>
// Copyright (c) MOSA Project. Licensed under the New BSD License.

// This code was generated by an automated template.

<# manager.EndBlock(); #>
<#
var path = System.IO.Path.GetFullPath(Host.TemplateFile+"\\..\\");
var json = File.ReadAllText(path+"\\..\\"+"X86Instructions.json");

var jss = new JavaScriptSerializer();
jss.RegisterConverters(new JavaScriptConverter[] { new DynamicJsonConverter() });

dynamic entries = jss.Deserialize(json, typeof(object)) as dynamic;

foreach (var entry in entries.Instructions) {

if (entry.X86EmitMethodType == null)
	continue;
#>

<# manager.StartNewFile(entry.Name+".cs"); #>
using Mosa.Compiler.Framework;
<# if (entry.ResultType != null || entry.ResultType2 != null) { #>
using Mosa.Compiler.MosaTypeSystem;
<# } #>

namespace Mosa.Platform.x86.Instructions
{
	/// <summary>
	/// <#= entry.Name #>
<# if (!string.IsNullOrWhiteSpace(entry.Description)) { #>
	/// <#= entry.Description #>
<# } #>
	/// </summary>
	/// <seealso cref="Mosa.Compiler.Framework.IR.BaseIRInstruction" />
	public sealed class <#= entry.Name #> : X86Instruction
	{
<# if (entry.X86EmitMethodType != null && entry.X86EmitMethodType == "SimpleByteCode") {

		bool first = true;
		string data = string.Empty;

		foreach (string b in entry.X86EmitBytes.Split(' '))
		{
			if (!first)
				data = data + ", ";

			data = data + "0x" + b;

			first = false;
		}
#>
		private static readonly byte[] opcode = new byte[] { <#= data #> };

		// for internal code generator use
		public override byte[] __opcode { get { return opcode; } }

<# } #>
		public <#= entry.Name #>()
			: base(<#= entry.ResultCount #>, <#= entry.OperandCount #>)
		{
		}
<# if (entry.FlowControl != null && entry.FlowControl != "Next") { #>

		public override FlowControl FlowControl { get { return FlowControl.<#= entry.FlowControl #>; } }
<# } #>
<# if (entry.ResultType != null && entry.ResultType != "") { #>

		public override BuiltInType ResultType { get { return BuiltInType.<#= entry.ResultType #>; } }
<# } #>
<# if (entry.ResultType2 != null && entry.ResultType2 != "") { #>

		public override BuiltInType ResultType2 { get { return BuiltInType.<#= entry.ResultType2 #>; } }
<# } #>
<# if (entry.IgnoreDuringCodeGeneration  != null && entry.IgnoreDuringCodeGeneration == "true") { #>

		public override bool IgnoreDuringCodeGeneration { get { return true; } }
<# } #>
<# if (entry.IgnoreInstructionBasicBlockTargets  != null && entry.IgnoreInstructionBasicBlockTargets == "true") { #>

		public override bool IgnoreInstructionBasicBlockTargets { get { return true; } }
<# } #>
<# if (entry.VariableOperands != null && entry.VariableOperands == "true") { #>

		public override bool VariableOperands { get { return true; } }
<# } #>
<# if (entry.Commutative  != null && entry.Commutative == "true") { #>

		public override bool Commutative { get { return true; } }
<# } #>
<# if (entry.MemoryWrite != null && entry.MemoryWrite == "true") { #>

		public override bool IsMemoryWrite { get { return true; } }
<# } #>
<# if (entry.MemoryRead != null && entry.MemoryRead == "true") { #>

		public override bool IsMemoryRead { get { return true; } }
<# } #>
<# if (entry.IOOperation != null && entry.IOOperation == "true") { #>

		public override bool IsIOOperation { get { return true; } }
<# } #>
<# if (entry.IRUnspecifiedSideEffect != null && entry.IRUnspecifiedSideEffect == "true") { #>

		public override bool HasIRUnspecifiedSideEffect { get { return true; } }
<# } #>
<# if (entry.X86ThreeTwoAddressConversion != null && entry.X86ThreeTwoAddressConversion != "true") { #>

		public override bool ThreeTwoAddressConversion { get { return false; } }
<# } #>
<# if (entry.X86EmitMethodType != null && entry.X86EmitMethodType == "SimpleByteCode"){ #>

		public override void Emit(InstructionNode node, BaseCodeEmitter emitter)
		{
			emitter.Write(opcode);
		}
<# } #>
	}
}
<# } #>
<# manager.EndBlock(); #>
<# manager.Process(true); #>
