<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@include file="..\..\Templates\DynamicJsonConverter.ttinclude" #>
<#@include file="..\..\Templates\MultipleOutputHelper.ttinclude" #>
<#@ assembly name="Microsoft.CSharp" #>
<# var manager = Manager.Create(Host, GenerationEnvironment); #> 
<# manager.StartHeader(); #>
// Copyright (c) MOSA Project. Licensed under the New BSD License.

// This code was generated by an automated template.

<# manager.EndBlock(); #>
<#
var path = System.IO.Path.GetFullPath(Host.TemplateFile+"\\..\\");
var json = File.ReadAllText(path+"\\..\\"+"X86Instructions.json");

var jss = new JavaScriptSerializer();
jss.RegisterConverters(new JavaScriptConverter[] { new DynamicJsonConverter() });

dynamic entries = jss.Deserialize(json, typeof(object)) as dynamic;

foreach (var entry in entries.Instructions) {

if (entry.X86EmitBytes == null && entry.X86LegacyOpcode == null && entry.StaticEmitMethod == null)
	continue;
#>

<# manager.StartNewFile(entry.Name+".cs"); #>
using Mosa.Compiler.Framework;
<# if (entry.ResultType != null || entry.ResultType2 != null) { #>
using Mosa.Compiler.MosaTypeSystem;
<# } #>

namespace Mosa.Platform.x86.Instructions
{
	/// <summary>
	/// <#= entry.Name #>
<# if (!string.IsNullOrWhiteSpace(entry.Description)) { #>
	/// <#= entry.Description #>
<# } #>
	/// </summary>
	/// <seealso cref="Mosa.Platform.x86.X86Instruction" />
	public sealed class <#= entry.Name #> : X86Instruction
	{
<#
		bool first = true;

		string bytes = string.Empty;
		if (entry.X86EmitBytes != null) {
			foreach (string b in entry.X86EmitBytes.Split(' '))
			{
				string b2 = b.Replace("0x",string.Empty).Replace(",",string.Empty);

				if (!first)
					bytes = bytes + ", ";

				bytes = bytes + "0x" + b2;

				first = false;
			}
		}
		string legacy = string.Empty;
		if (entry.X86LegacyOpcode != null) {
			first = true;
			foreach (string b in entry.X86LegacyOpcode.Split(' '))
			{
				string b2 = b.Replace("0x",string.Empty).Replace(",",string.Empty);

				if (!first)
					legacy = legacy + ", ";

				legacy = legacy + "0x" + b2;

				first = false;
			}
		}

		string reg = string.Empty;
		if (entry.X86LegacyOpcodeRegField != null)
			reg = ", 0x" + entry.X86LegacyOpcodeRegField.Replace("0x",string.Empty);

		string operands = string.Empty;
		if (!string.IsNullOrWhiteSpace(entry.X86LegacyOpcodeOperandOrder))
		{
			var sb = new StringBuilder();

			foreach(var c in entry.X86LegacyOpcodeOperandOrder)
			{
				if (c == 'R' || c == 'r')
				{
					sb.Append("node.Result");
				}
				else if (c == '1')
				{
					sb.Append("node.Operand1");
				}
				else if (c == '2')
				{
					sb.Append("node.Operand2");
				} 
				else if (c == '3')
				{
					sb.Append("node.Operand3");
				}
				else if (c == 'N' || c == 'n')
				{
					sb.Append("node.Result");
				}
				sb.Append(", ");
			}

			sb.Length--;
			sb.Length--;

			operands = sb.ToString();
		}
#>
<# if (entry.AlternativeName != null) { #>
		public override string AlternativeName { get { return "<#= entry.AlternativeName #>"; } }

<# } #>
<# if (entry.X86EmitBytes != null) { #>
		public static readonly byte[] opcode = new byte[] { <#= bytes #> };

<# } #>
<# if (entry.X86LegacyOpcode != null) { #>
		public static readonly LegacyOpCode LegacyOpcode = new LegacyOpCode(new byte[] { <#= legacy #> } <#= reg #>);

<# } #>
		internal <#= entry.Name #>()
			: base(<#= entry.ResultCount #>, <#= entry.OperandCount #>)
		{
		}
<# if (entry.FlowControl != null && entry.FlowControl != "Next") { #>

		public override FlowControl FlowControl { get { return FlowControl.<#= entry.FlowControl #>; } }
<# } #>
<# if (entry.ResultType != null && entry.ResultType != "") { #>

		public override BuiltInType ResultType { get { return BuiltInType.<#= entry.ResultType #>; } }
<# } #>
<# if (entry.ResultType2 != null && entry.ResultType2 != "") { #>

		public override BuiltInType ResultType2 { get { return BuiltInType.<#= entry.ResultType2 #>; } }
<# } #>
<# if (entry.IgnoreDuringCodeGeneration  != null && entry.IgnoreDuringCodeGeneration == "true") { #>

		public override bool IgnoreDuringCodeGeneration { get { return true; } }
<# } #>
<# if (entry.IgnoreInstructionBasicBlockTargets  != null && entry.IgnoreInstructionBasicBlockTargets == "true") { #>

		public override bool IgnoreInstructionBasicBlockTargets { get { return true; } }
<# } #>
<# if (entry.VariableOperands != null && entry.VariableOperands == "true") { #>

		public override bool VariableOperands { get { return true; } }
<# } #>
<# if (entry.Commutative  != null && entry.Commutative == "true") { #>

		public override bool IsCommutative { get { return true; } }
<# } #>
<# if (entry.MemoryWrite != null && entry.MemoryWrite == "true") { #>

		public override bool IsMemoryWrite { get { return true; } }
<# } #>
<# if (entry.MemoryRead != null && entry.MemoryRead == "true") { #>

		public override bool IsMemoryRead { get { return true; } }
<# } #>
<# if (entry.IOOperation != null && entry.IOOperation == "true") { #>

		public override bool IsIOOperation { get { return true; } }
<# } #>
<# if (entry.UnspecifiedSideEffect != null && entry.UnspecifiedSideEffect == "true") { #>

		public override bool HasIRUnspecifiedSideEffect { get { return true; } }
<# } #>
<# if (entry.X86ThreeTwoAddressConversion == null || (entry.X86ThreeTwoAddressConversion != null && entry.X86ThreeTwoAddressConversion != "true")) { #>

		public override bool ThreeTwoAddressConversion { get { return false; } }
<# } #>
<# if (entry.LogicalOpposite != null) { #>

		public override BaseInstruction GetOpposite()
		{
			return <#= entry.FamilyName #>.<#=entry.LogicalOpposite#>;
		}
<# } #>
<# if (entry.X86EmitBytes != null){ #>

		public override void Emit(InstructionNode node, BaseCodeEmitter emitter)
		{
<# if (entry.VariableOperands == null || entry.VariableOperands == "false") { #>
			System.Diagnostics.Debug.Assert(node.ResultCount == <#= entry.ResultCount #>);
			System.Diagnostics.Debug.Assert(node.OperandCount == <#= entry.OperandCount #>);
<# if (entry.X86EmitRelativeBranchTarget != null || entry.X86EmitRelativeBranchTarget == "true") { #>
			System.Diagnostics.Debug.Assert(node.BranchTargets.Count >= 1);
			System.Diagnostics.Debug.Assert(node.BranchTargets[0] != null);
<# } #>

<# } #>
			emitter.Write(opcode);
<# if (entry.X86EmitRelativeBranchTarget != null || entry.X86EmitRelativeBranchTarget == "true") { #>
			(emitter as X86CodeEmitter).EmitRelativeBranchTarget(node.BranchTargets[0].Label);
<# } #>
		}
<# } #>
<# if (entry.StaticEmitMethod != null){ #>

		public override void Emit(InstructionNode node, BaseCodeEmitter emitter)
		{
<# if (entry.VariableOperands == null || entry.VariableOperands == "false") { #>
			System.Diagnostics.Debug.Assert(node.ResultCount == DefaultResultCount);
			System.Diagnostics.Debug.Assert(node.OperandCount == DefaultOperandCount);

<# } #>
			<#= entry.StaticEmitMethod.Replace("%", entry.Name) #>(node, emitter);
		}
<# } #>
<# if (entry.X86LegacyOpcodeOperandOrder != null && entry.X86LegacyOpcode != null && entry.StaticEmitMethod == null){ #>

		internal override void EmitLegacy(InstructionNode node, X86CodeEmitter emitter)
		{
<# if (entry.VariableOperands == null || entry.VariableOperands == "false") { #>
			System.Diagnostics.Debug.Assert(node.ResultCount == <#= entry.ResultCount #>);
			System.Diagnostics.Debug.Assert(node.OperandCount == <#= entry.OperandCount #>);
<# if (entry.X86ThreeTwoAddressConversion == null || entry.X86ThreeTwoAddressConversion == "true") { #>
			System.Diagnostics.Debug.Assert(node.Result == node.Operand1);
			System.Diagnostics.Debug.Assert(node.Result.IsCPURegister);
			System.Diagnostics.Debug.Assert(node.Operand1.IsCPURegister);
<# } #>

<# } #>
<# if (operands == "") { #>
			emitter.Emit(LegacyOpcode);
<# } else { #>
			emitter.Emit(LegacyOpcode, <#= operands #>);
<# } #>
		}
<# } #>
<# if (entry.X86EmitBytes != null || entry.X86LegacyOpcode != null || entry.StaticEmitMethod != null) { #>

		// The following is used by the automated code generator.
<# } #>
<# if (entry.X86EmitBytes != null) { #>

		public override byte[] __opcode { get { return opcode; } }
<# } #>
<# if (entry.X86LegacyOpcode != null) { #>

		public override LegacyOpCode __legacyopcode { get { return LegacyOpcode; } }
<# } #>
<# if (entry.StaticEmitMethod != null) { #>

		public override string __staticEmitMethod { get { return "<#= entry.StaticEmitMethod #>"; } }
<# } #>
<# if (entry.X86LegacyOpcodeOperandOrder != null) { #>

		public override string __legacyOpcodeOperandOrder { get { return "<#= entry.X86LegacyOpcodeOperandOrder #>"; } }
<# } #>	}
}
<# } #>
<# manager.EndBlock(); #>
<# manager.Process(true); #>
