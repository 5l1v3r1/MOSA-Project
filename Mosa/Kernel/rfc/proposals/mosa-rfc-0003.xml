<?xml version='1.0' encoding='UTF-8'?>
<?xml-stylesheet type='text/xsl' href='../tools/mosa-rfc-transform.xsl'?>

<rfc xmlns='http://www.mosa.org/schemas/mosa-rfc.xsd'>

  <header>
    <title>MOSA Physical Memory Page Management Interfaces</title>
    <abstract>This specification defines the interface of a MOSA compliant physical memory page manager.</abstract>
    <number>0003</number>
    <status>Proposal</status>
    <type>Informational</type>
    <sig>Standards</sig>
    <dependencies>
      <spec>0002</spec>
    </dependencies>
    <supersedes/>
    <supersededby/>
    <author>
      <firstname>Michael</firstname>
      <surname>Ruck</surname>
      <org>MOSA</org>
    </author>
    <revision>
      <version>0.0.1</version>
      <date>2008-08-06T00:00:00.0000000+00:00</date>
      <initials>mr</initials>
      <remark>
        <p>First draft.</p>
      </remark>
    </revision>
    <revision>
      <version>0.0.2</version>
      <date>2008-08-06T00:00:00.0000000+00:00</date>
      <initials>mr</initials>
      <remark>
        <p>Changed IMemoryPageManager properties to return ulong instead of uint.</p>
      </remark>
    </revision>
    <revision>
      <version>0.0.3</version>
      <date>2008-08-06T00:00:00.0000000+00:00</date>
      <initials>mr</initials>
      <remark>
        <p>Removed xmldocs for flags parameters that don't exist.</p>
      </remark>
    </revision>
    <conformanceterms used='true'/>
  </header>

  <section1 topic='Introduction' anchor='intro'>
    <p>
      One of the core operating system services is memory management. This RFC attempts to standardize
      on a common interface for physical memory page management. Memory management can be abstracted into
      several individual components, such as:
    </p>
    <ul>
      <li>Physical Pages</li>
      <li>Paging Service</li>
      <li>Process Memory Manager</li>
      <li>Heaps</li>
      <li>Garbage Collector</li>
    </ul>
    <p>
      This RFC discusses the very first component. The responsibilities of the other components shall be 
      described in the next sections.
    </p>
  </section1>

  <section2 topic='Paging Service' anchor='paging'>
    <p>
      The paging service is responsible for swapping physical pages corresponding to virtual memory regions
      of individual processes respective to specific events, such as read/write access and low memory 
      conditions. The paging service builds on top of the physical page manager. A specification of this
      service interface is to be defined in a seperate RFC. t.b.d.
    </p>
  </section2>

  <section2 topic='Process Memory Manager' anchor='pmm'>
    <p>
      The process memory manager is responsible for the layout of virtual memory inside a single process. This
      component is instantiated inside each process. A specification of this interface is to be defined in a 
      seperate RFC. t.b.d.
    </p>
  </section2>

  <section2 topic='Heaps' anchor='heaps'>
    <p>
      A heap is used by actual object memory allocations. A heap divides memory in fine granular components. A
      specification of this interface is to be defined in a seperate RFC. t.b.d.
    </p>
  </section2>

  <section2 topic='Garbage Collector' anchor='heaps'>
    <p>
      The garbage collector is responsible for cleaning up a single heap. A specification of this interface is 
      to be defined in a seperate RFC. t.b.d.
    </p>
  </section2>

  <section1 topic='Required Features' anchor='reqfeatures'>
    <p>
      A physical memory page manager is responsible for allocation, protection and release of physical pages of
      memory. It is the lowest component in the memory management hierarchy. The following list summarizes
      the features required from a physical page manager:
      <ul>
        <li>It MUST support the allocation of ranges of physical memory.</li>
        <li>It MUST support the release of a range of physical memory.</li>
        <li>It MUST support page protection settings, like read, write, execute for each page.</li>
        <li>It SHALL support the retrieval of system specific information, such as page size and the total amount of memory.</li>
        <li>It SHALL support the retrieval of memory use statistics.</li>
      </ul>
    </p>
  </section1>

  <section1 topic='Interfaces' anchor='interfaces'>
    <p>
      The interface of the physical memory page manager consists of a single interface and an enumeration described below.
    </p>

  <section2 topic='IMemoryPageManager' anchor='IMemoryPageManager'>
    <p>
      The following code defines the interface of the memory page manager:

      <code>
      namespace Mosa.Kernel.Memory
      {
        /// &lt;summary&gt;
        /// Interface of a memory page manager.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;
        /// This interface defines the abstract operations to allocate, free and manage ranges
        /// of memory at the page level.
        /// &lt;/remarks&gt;
        public interface IMemoryPageManager
        {
          /// &lt;summary&gt;
          /// Reserves or commits a range of pages.
          /// &lt;/summary&gt;
          /// &lt;param name="address"&gt;A starting address from a previous call, which reserved memory or IntPtr.Zero.&lt;/param&gt;
          /// &lt;param name="size"&gt;The number of bytes to reserve.&lt;/param&gt;
          /// &lt;param name="protectionFlags"&gt;One or more flag that controls the protection of the retrieved pages.&lt;/param&gt;
          /// &lt;returns&gt;An IntPtr to the allocated memory.&lt;/returns&gt;
          IntPtr Allocate(IntPtr address, ulong size, PageProtectionFlags protectionFlags);

          /// &lt;summary&gt;
          /// Releases or decommits a range of pages.
          /// &lt;/summary&gt;
          /// &lt;param name="address"&gt;The starting address, where pages are freed.&lt;/param&gt;
          /// &lt;param name="size"&gt;The number of bytes to free.&lt;/param&gt;
          void Free(IntPtr address, ulong size);

          /// &lt;summary&gt;
          /// Changes the protection bits of the pages associated with the given range of memory.
          /// &lt;/summary&gt;
          /// &lt;param name="address"&gt;The starting address.&lt;/param&gt;
          /// &lt;param name="size"&gt;The number of bytes.&lt;/param&gt;
          /// &lt;param name="protectionFlags"&gt;The new set of protection flags.&lt;/param&gt;
          /// &lt;returns&gt;The old protection flags of the first page in the range of memory. &lt;/returns&gt;
          PageProtectionFlags Protect(IntPtr address, ulong size, PageProtectionFlags protectionFlags);

          /// &lt;summary&gt;
          /// Retrieves the size of a single memory page.
          /// &lt;/summary&gt;
          ulong PageSize { get; }

          /// &lt;summary&gt;
          /// Retrieves the amount of total memory available in the system.
          /// &lt;/summary&gt;
          ulong TotalMemory { get; }

          /// &lt;summary&gt;
          /// Retrieves the amount of physical memory currently in use.
          /// &lt;/summary&gt;
          ulong TotalMemoryInUse { get; }
        }
      }
      </code>
    </p>
  </section2>

  <section2 topic='PageProtectionFlags enumeration' anchor='ppfenum'>
    <p>
      The PageProtectionFlags enumeration defines various flags that control the page protection attributes:
      
      <code>
        namespace Mosa.Kernel.Memory
        {
          /// &lt;summary&gt;
          /// Specifies memory protection flags.
          /// &lt;/summary&gt;
          [Flags]
          public enum PageProtectionFlags
          {
            /// &lt;summary&gt;
            /// No access is allowed to the page.
            /// &lt;/summary&gt;
            NoAccess = 0,

            /// &lt;summary&gt;
            /// The page can only be read.
            /// &lt;/summary&gt;
            Read = 1,

            /// &lt;summary&gt;
            /// The page can only be written.
            /// &lt;/summary&gt;
            Write = 2,

            /// &lt;summary&gt;
            /// The page can be executed.
            /// &lt;/summary&gt;
            Execute = 4,

            /// &lt;summary&gt;
            /// The page is a guard page.
            /// &lt;/summary&gt;
            Guard = 0x10000000,

            /// &lt;summary&gt;
            /// The processor is allowed to defer writes to the page to full cache lines.
            /// &lt;/summary&gt;
            WriteCombine = 0x20000000,

            /// &lt;summary&gt;
            /// The page may not be cached by the processor.
            /// &lt;/summary&gt;
            NoCache = 0x40000000
          }
        }
      </code>
    </p>
  </section2>
  </section1>

</rfc>
