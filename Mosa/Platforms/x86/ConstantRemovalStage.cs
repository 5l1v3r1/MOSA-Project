/*
 * (c) 2008 MOSA - The Managed Operating System Alliance
 *
 * Licensed under the terms of the New BSD License.
 *
 * Authors:
 *  Michael Ruck (<mailto:sharpos@michaelruck.de>)
 */

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;

using Mosa.Runtime.Metadata;
using Mosa.Runtime.CompilerFramework;
using IR = Mosa.Runtime.CompilerFramework.IR;

namespace Mosa.Platforms.x86
{
    /// <summary>
    /// This is an x86 specific compiler stage to remove floating point constants from instructions.
    /// </summary>
    /// <remarks>
    /// The code generated by the x86 compiler is position independent. However x86 does not allow
    /// embedding floating point values as immediates inside the code, so these have to be moved outside
    /// and referenced through a memory offset starting at the 
    /// </remarks>
    public sealed class ConstantRemovalStage : 
        IMethodCompilerStage
    {
        #region Data members

        /// <summary>
        /// If true it indicates that this compiler stage has moved at least 
        /// one floating point constant to physical memory.
        /// </summary>
        private bool _constantRemoved;

        #endregion // Data members

        #region Construction

        /// <summary>
        /// Initializes a new instance of <see cref="ConstantRemovalStage"/>.
        /// </summary>
        public ConstantRemovalStage()
        {
        }

        #endregion // Construction

        #region Properties

        /// <summary>
        /// Gets the existance of FP constants in the instruction stream.
        /// </summary>
        public bool ConstantRemoved
        {
            get { return _constantRemoved; }
        }

        #endregion // Properties

        #region IMethodCompilerStage Members

        /// <summary>
        /// Retrieves the name of the compilation stage.
        /// </summary>
        /// <value>The name of the compilation stage.</value>
        public string Name
        {
            get { return @"ConstantRemovalStage"; }
        }

        /// <summary>
        /// Runs the specified method compiler.
        /// </summary>
        /// <param name="methodCompiler">The method compiler.</param>
        public void Run(IMethodCompiler methodCompiler)
        {
            if (null == methodCompiler)
                throw new ArgumentNullException(@"methodCompiler");

            List<Instruction> literals = new List<Instruction>();
            IArchitecture arch = methodCompiler.Architecture;

            // Is the method split into basic Blocks?
            IBasicBlockProvider blockProvider = (IBasicBlockProvider)methodCompiler.GetPreviousStage(typeof(IBasicBlockProvider));
            if (null == blockProvider)
            {
                // No, operate on the raw instruction stream
                IInstructionsProvider ip = (IInstructionsProvider)methodCompiler.GetPreviousStage(typeof(IInstructionsProvider));
                if (null != ip)
                    ProcessInstructions(arch, ip.Instructions, literals);

                ip.Instructions.AddRange(literals);
            }
            else
            {
                BasicBlock epilogue = blockProvider.FromLabel(Int32.MaxValue);

                // Iterate all Blocks and collect locals from all Blocks
                foreach (BasicBlock block in blockProvider)
                    ProcessInstructions(arch, block.Instructions, literals);

                epilogue.Instructions.AddRange(literals);
            }

            _constantRemoved = (0 != literals.Count);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pipeline"></param>
        public void AddToPipeline(CompilerPipeline<IMethodCompilerStage> pipeline)
        {
            pipeline.InsertAfter<EnterSSA>(this);
        }

        #endregion // IMethodCompilerStage Members

        #region Internals

        /// <summary>
        /// Enumerates all instructions and eliminates floating point constants from them.
        /// </summary>
        /// <param name="architecture">The architecture used to create literals.</param>
        /// <param name="instructions">The instruction list to enumerate.</param>
        /// <param name="literals">A list of instructions to add the literals to.</param>
        private static void ProcessInstructions(IArchitecture architecture, IEnumerable<Instruction> instructions, IList<Instruction> literals)
        {
            // Current constant operand
            ConstantOperand co = null;
            // Operand index in an instruction
            int opIdx = 0;

            foreach (Instruction instruction in instructions)
            {
                // A constant may only appear on the right side of an expression, so we ignore constants in
                // Instruction.Result - there should never be one there.
                opIdx = 0;
                foreach (Operand op in instruction.Operands)
                {
                    co = op as ConstantOperand;
                    if (null != co && true == IsLargeConstant(co))
                    {
                        // Move the constant out of the code stream and place it right after
                        // the code.
                        Instructions.LiteralInstruction literal = (Instructions.LiteralInstruction)architecture.CreateInstruction(typeof(Instructions.LiteralInstruction), instruction.Offset, co.Type, co.Value);
                        co.Replace(literal.CreateOperand());
                        literals.Add(literal);
                    }

                    opIdx++;
                }
            }
        }

        /// <summary>
        /// Determines if the given constant operand is a large constant.
        /// </summary>
        /// <remarks>
        /// Only constants, which have special types or do not fit into an immediate argument
        /// are large and are moved to memory.
        /// </remarks>
        /// <param name="co">The constant operand to check.</param>
        /// <returns>True if the constant is large and needs to be moved to a literal.</returns>
        private static bool IsLargeConstant(ConstantOperand co)
        {
            // Check the type of the constant operand against this list of large CIL types,
            // that need special handling.
            CilElementType[] largeCilTypes = {
                CilElementType.R4,
                CilElementType.R8,
                CilElementType.I8,
                CilElementType.U8
            };

            return (-1 != Array.IndexOf<CilElementType>(largeCilTypes, co.Type.Type));
        }

        #endregion // Internals
    }
}
